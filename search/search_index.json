{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geenext","text":"<p>A python package to extend the capabilities of Google Earth Engine in the field of Al and ML.</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://geonextgis.github.io/geenext</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#geenext.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>geenext/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\n    \"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/geonextgis/geenext/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>geenext could always use more documentation, whether as part of the official geenext docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/geonextgis/geenext/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up geenext for local development.</p> <ol> <li> <p>Fork the geenext repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/geenext.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv geenext\n$ cd geenext/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 geenext tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/geonextgis/geenext/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"extraction/","title":"extraction module","text":"<p>A module to extract large volume datasets for machine learning from Google Earth Engine.</p>"},{"location":"extraction/#geenext.extraction.extract_pixel_values_by_points","title":"<code>extract_pixel_values_by_points(image_collection, points_gdf, date_ranges_df, scale=250, copy_properties=['point_id'], reducer='mean', dtype=None, constant_value=0)</code>","text":"<p>Extracts pixel values from an Earth Engine image collection for specified points over defined date ranges using a specified statistical reducer (e.g., mean, median, sum).</p> <p>Parameters:</p> Name Type Description Default <code>image_collection</code> <code>ee.ImageCollection</code> <p>The Earth Engine image collection from which to extract data.</p> required <code>points_gdf</code> <code>geopandas.GeoDataFrame</code> <p>A GeoDataFrame containing the points with associated properties.</p> required <code>date_ranges_df</code> <code>pd.DataFrame</code> <p>A DataFrame with columns 'start_date', 'end_date', and 'label_prefix' defining date ranges.</p> required <code>scale</code> <code>int</code> <p>The spatial resolution in meters at which to extract data. Defaults to 250.</p> <code>250</code> <code>copy_properties</code> <code>list of str</code> <p>List of properties from the points_gdf to retain in the output. Defaults to [\"point_id\"].</p> <code>['point_id']</code> <code>reducer</code> <code>str</code> <p>The statistical reducer to apply to the image collection. Options include \"mean\", \"median\", \"min\", \"max\", \"sum\", \"stdDev\", \"variance\". Defaults to \"mean\".</p> <code>'mean'</code> <code>dtype</code> <code>str or np.dtype</code> <p>Data type to which the extracted values should be cast. Defaults to None.</p> <code>None</code> <code>constant_value</code> <code>int or float</code> <p>The value to use for constant bands if no bands are present in the image. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A DataFrame containing the extracted pixel values, with one row per point per date range.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If 'date_ranges_df' does not contain 'start_date' or 'end_date'.</p> <code>ValueError</code> <p>If 'reducer' is not a valid Earth Engine reducer.</p> <code>ValueError</code> <p>If 'dtype' is not a valid data type.</p> Source code in <code>geenext/extraction.py</code> <pre><code>def extract_pixel_values_by_points(image_collection, points_gdf, date_ranges_df, scale=250, \n                                   copy_properties=[\"point_id\"], reducer=\"mean\", dtype=None,\n                                   constant_value=0):\n    \"\"\"\n    Extracts pixel values from an Earth Engine image collection for specified points over defined date ranges\n    using a specified statistical reducer (e.g., mean, median, sum).\n\n    Args:\n        image_collection (ee.ImageCollection): The Earth Engine image collection from which to extract data.\n        points_gdf (geopandas.GeoDataFrame): A GeoDataFrame containing the points with associated properties.\n        date_ranges_df (pd.DataFrame): A DataFrame with columns 'start_date', 'end_date', and 'label_prefix' defining date ranges.\n        scale (int, optional): The spatial resolution in meters at which to extract data. Defaults to 250.\n        copy_properties (list of str, optional): List of properties from the points_gdf to retain in the output. Defaults to [\"point_id\"].\n        reducer (str, optional): The statistical reducer to apply to the image collection. Options include \"mean\", \"median\", \"min\", \"max\", \"sum\", \"stdDev\", \"variance\". Defaults to \"mean\".\n        dtype (str or np.dtype, optional): Data type to which the extracted values should be cast. Defaults to None.\n        constant_value (int or float, optional): The value to use for constant bands if no bands are present in the image. Defaults to 0.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the extracted pixel values, with one row per point per date range.\n\n    Raises:\n        ValueError: If 'date_ranges_df' does not contain 'start_date' or 'end_date'.\n        ValueError: If 'reducer' is not a valid Earth Engine reducer.\n        ValueError: If 'dtype' is not a valid data type.\n    \"\"\"\n\n    # Validate date_ranges_df input\n    if 'start_date' not in date_ranges_df.columns or 'end_date' not in date_ranges_df.columns:\n        raise ValueError(\"date_ranges_df must contain 'start_date' and 'end_date' columns.\")\n\n    # Map reducer strings to corresponding Earth Engine reducer functions\n    reducers = {\n        \"mean\": ee.Reducer.mean(),\n        \"median\": ee.Reducer.median(),\n        \"min\": ee.Reducer.min(),\n        \"max\": ee.Reducer.max(),\n        \"sum\": ee.Reducer.sum(),\n        \"stdDev\": ee.Reducer.stdDev(),\n        \"variance\": ee.Reducer.variance()\n    }\n\n    if reducer not in reducers:\n        raise ValueError(f\"Invalid reducer '{reducer}'. Valid options are {list(reducers.keys())}.\")\n\n    # Store the band names from the image collection\n    band_names = image_collection.first().bandNames().getInfo()\n\n    # Split the points into batches if the number of points exceeds 1000\n    batch_ranges = []\n    total_points = len(points_gdf)\n    batch_interval = 1000\n\n    for start in range(0, total_points, batch_interval):\n        end = min(start + batch_interval, total_points)\n        batch_ranges.append((start, end))\n\n    # Prepare images for all date ranges using the specified reducer\n    daterange_images = ee.List([])\n\n    for _, row in date_ranges_df.iterrows():\n        start_date = row[\"start_date\"].strftime(\"%Y-%m-%d\")\n        end_date = row[\"end_date\"].strftime(\"%Y-%m-%d\")\n        label = row.get(\"label\", None)\n\n        image = image_collection.filterDate(start_date, end_date).reduce(reducers[reducer])\n\n        # If the image has no bands, add constant bands for each expected band\n        if image.bandNames().size().getInfo() == 0:\n            constant_image = ee.Image.constant(constant_value).rename(band_names)\n            image = constant_image\n\n        if label:\n            image = image.select([f\"{band}_{reducer}\" for band in band_names], [f\"{band}_{label}\" for band in band_names])\n\n        daterange_images = daterange_images.add(image)\n\n    # Convert the list of images into an ImageCollection and then to bands\n    daterange_images = ee.ImageCollection(daterange_images).toBands()\n\n    # Get and adjust band names\n    daterange_band_names = daterange_images.bandNames().getInfo()\n    if label:\n        adjusted_band_names = [\"_\".join(name.split(\"_\")[1:]) for name in daterange_band_names]\n        daterange_images = daterange_images.select(daterange_band_names, adjusted_band_names)\n\n    # Initialize an empty DataFrame to store the extracted data\n    extracted_data = pd.DataFrame()\n\n    print(\"Processing in batches...\")\n    for batch_start, batch_end in tqdm(batch_ranges):\n        points_batch = points_gdf.iloc[batch_start:batch_end]\n        points_batch = points_batch[copy_properties + [\"geometry\"]]\n        points_batch_ee = geemap.gdf_to_ee(points_batch)\n\n        # Extract data for the current batch\n        batch_data = daterange_images.reduceRegions(\n            collection=points_batch_ee,\n            reducer=ee.Reducer.first(),\n            scale=scale\n        )\n\n        # Convert the Earth Engine result to a DataFrame\n        batch_df = geemap.ee_to_df(batch_data)\n\n        if dtype:\n            try:\n                batch_df[adjusted_band_names] = batch_df[adjusted_band_names].astype(dtype)\n                batch_df = batch_df[copy_properties + adjusted_band_names]\n            except ValueError:\n                raise ValueError(\"Provided dtype is not a valid data type.\")\n\n        # Concatenate the batch data to the final DataFrame\n        extracted_data = pd.concat([extracted_data, batch_df], axis=0, ignore_index=True)\n\n    return extracted_data\n</code></pre>"},{"location":"extraction/#geenext.extraction.generate_date_ranges","title":"<code>generate_date_ranges(start_date_str, end_date_str, interval_days, label_prefix=None)</code>","text":"<p>Generates a DataFrame containing date ranges between a start and end date with a specified interval.</p> <p>Parameters:</p> Name Type Description Default <code>start_date_str</code> <code>str</code> <p>The start date as a string in the format 'YYYY-MM-DD'.</p> required <code>end_date_str</code> <code>str</code> <p>The end date as a string in the format 'YYYY-MM-DD'.</p> required <code>interval_days</code> <code>int</code> <p>The number of days between the start and end of each interval.</p> required <code>label_prefix</code> <code>str</code> <p>A prefix to be used in labeling each date range. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A DataFrame with columns 'start_date', 'end_date', and 'label' where each row represents a date range.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If 'start_date_str' or 'end_date_str' is not in the 'YYYY-MM-DD' format.</p> <code>ValueError</code> <p>If 'interval_days' is not a positive integer.</p> Source code in <code>geenext/extraction.py</code> <pre><code>def generate_date_ranges(start_date_str, end_date_str, interval_days, label_prefix=None):\n    \"\"\"\n    Generates a DataFrame containing date ranges between a start and end date with a specified interval.\n\n    Args:\n        start_date_str (str): The start date as a string in the format 'YYYY-MM-DD'.\n        end_date_str (str): The end date as a string in the format 'YYYY-MM-DD'.\n        interval_days (int): The number of days between the start and end of each interval.\n        label_prefix (str, optional): A prefix to be used in labeling each date range. Defaults to None.\n\n    Returns:\n        pd.DataFrame: A DataFrame with columns 'start_date', 'end_date', and 'label' where each row represents a date range.\n\n    Raises:\n        ValueError: If 'start_date_str' or 'end_date_str' is not in the 'YYYY-MM-DD' format.\n        ValueError: If 'interval_days' is not a positive integer.\n    \"\"\"\n\n    # Validate input formats\n    try:\n        start_date = datetime.strptime(start_date_str, \"%Y-%m-%d\")\n        end_date = datetime.strptime(end_date_str, \"%Y-%m-%d\")\n    except ValueError:\n        raise ValueError(\"start_date_str and end_date_str must be in the format 'YYYY-MM-DD'.\")\n\n    # Validate that end_date is greater than start_date\n    if end_date &lt;= start_date:\n        raise ValueError(\"end_date_str must be greater than start_date_str.\")\n\n    if not isinstance(interval_days, int) or interval_days &lt;= 0:\n        raise ValueError(\"interval_days must be a positive integer.\")\n\n    start_dates = []\n    end_dates = []\n\n    while start_date &lt;= end_date:\n        start_dates.append(start_date)\n        interval_end_date = start_date + timedelta(days=interval_days)\n        end_dates.append(interval_end_date)\n        start_date = interval_end_date\n\n    # Create DataFrame with the date ranges and labels\n    date_ranges_df = pd.DataFrame({\n        \"start_date\": start_dates, \n        \"end_date\": end_dates\n    })\n\n    # Generate labels if label_prefix is provided\n    if label_prefix is not None:\n        date_ranges_df[\"label\"] = [f\"{label_prefix}_{i + 1}\" for i in range(date_ranges_df.shape[0])]\n\n    return date_ranges_df\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"geenext/","title":"geenext module","text":"<p>Main module.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install geenext, run this command in your terminal:</p> <pre><code>pip install geenext\n</code></pre> <p>This is the preferred method to install geenext, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install geenext from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/geonextgis/geenext\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use geenext in a project:</p> <pre><code>import geenext\n</code></pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>print('Hello World!')\n</pre> print('Hello World!') <pre>Hello World!\n</pre>"}]}